---
title: "WIP: New function `propop::propop_tables()`"
subtitle: "Run projections with `tibbles`, `purrr` and `dplyr`"
author: "Statistik Aargau (2025), Norah Efosa"
date: August 2025
format:
  html:
    embed-resources: true
    link-external-icon: true
    theme: lumen 
    link-external-newwindow: true
    toc: true
    toc-location: left
    toc-title: "Interactive toc"
    toc-depth: 5
editor_options: 
  chunk_output_type: console
cache: false
---

# Introduction

`propop::propop_tables()` is a `dplyr`-version of `propop::propop()` (matrices).

✅modular structure

✅uses dplyr

✅more flexibility for adding/removing columns and new modules

✅for now, both functions will be kept and maintained

```{r packages, echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE}
# Install propop from the development branch
# devtools::install_github("statistik-aargau/propop", ref = "f-proj-tables2025-2055")

# Load packages
library(propop)
library(dplyr)

add_percent <- function(x) {
  paste0(x, "%")
}
options(scipen = 999)
```

## Overview: `propop_tables()`

### Function arguments

The new function's arguments are identical to `propop::propop()`:

(only the first four arguments in blue are mandatory)

```{r, echo = TRUE, eval = FALSE}
propop::propop_tables(
  parameters,
  population,
  year_first,
  year_last,
  scenarios = NULL,
  age_groups = 101,
  fert_first = 16,
  fert_last = 50,
  share_born_female = 100 / 205,
  subregional = NULL, # = "net" for net migration; = "rate" for emi- and immigration rates
  binational = TRUE,
  spatial_unit = "spatial_unit"
)
```

### Structure

![](overview_propop_tables.png)

#### Excerpt from `propop_tables()`

```{r, echo = TRUE, eval = FALSE}
# [...]
# Run projection ----
# iterate across spatial units, scenarios and years
df_result <- purrr::reduce(
  .x = list_parameters,
  .f = \(population, parameters) project_population(
    population, parameters,
    subregional = subregional
  ),
  .init = init_population
)
# [...]
```

### Performance for one region (Canton of Aargau)

We use STAT-TAB data as described in the [vignette for projecting a single region](vignettes/project_single_region.Rmd):

```{r message = FALSE, warning = FALSE, result = FALSE}
# Run propop with tables (new feature)
system.time({
  result_tables <- propop::propop_tables(
    parameters = fso_parameters,
    year_first = 2024,
    year_last = 2055,
    population = fso_population,
    binational = TRUE
  )
})

# Run propop with matrices (original)
system.time({
  result_matrices <- propop::propop(
    parameters = fso_parameters,
    year_first = 2024,
    year_last = 2055,
    population = fso_population,
    binational = TRUE
  )
})
```

#### Comparison between FSO-results, `propop::propop_tables()` and `propop::propop()`

```{r comparison-propop, echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE, result = FALSE}
# Split results by scenario
## FSO results
list_fso_results <- split(fso_parameters, fso_parameters$scen)
## Results from propop with matrices
# list_propop_matrices <- split(result_matrices, result_matrices$scen)
## Results from propop with tables
list_propop_tables <- split(result_tables, result_tables$scen)

# Define function comparing the FSO results (= benchmark) to propop with
# matrices/tables. (See function documentations of 'R/prepare_evaluation.R' and
# 'R/compute_measures.R').
compare_result <- function(
    df_fso_results,
    df_projection_result
  ) {
  # Match projection length between model results
  df_bench <- df_fso_results |> dplyr::filter(year %in% c(2024:2055))
  df_proj <- df_projection_result |> dplyr::filter(year %in% c(2024:2055))

  # Compare results
  df_result <- prepare_evaluation(
    data_benchmark = df_bench,
    n_benchmark = "fso_projection_n",
    data_projected = df_proj,
    n_projected = "n_dec",
    age_groups = "age_groups_5"
  ) |>
    compute_measures()

  return(df_result)
}

# Comparison between FSO results and propop with tables

fso_comparison_tables <- purrr::map2(
  list_fso_results, 
  list_propop_tables, 
  compare_result
) |>
  purrr::reduce(bind_rows)
```

```{r plot, echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE}
# Plot percentage error
fso_comparison_tables |>
  dplyr::mutate(sex_nat = paste0(sex, "_", nat), age = factor(age)) |>
  ggplot2::ggplot(ggplot2::aes(x = year, y = pe, color = age, pch = sex_nat)) +
  ggplot2::geom_jitter(size = 0.8) +
  ggplot2::scale_color_manual(values = c(
    "age_00_19" = "#007AB8",
    "age_20_39" = "#ffa81f",
    "age_40_59" = "#A05388",
    "age_60_79" = "#ffe562",
    "age_80_plus" = "#96D4FF"
  )) +
  ggplot2::labs(
    title = "Differences between FSO and propop_tables (2024-2055)",
    x = "Year",
    y = "Difference in percent"
  ) +
  ggplot2::guides(
    color = ggplot2::guide_legend(title = "age"),
    pch = ggplot2::guide_legend(title = "nationality and sex")
  ) +
  ggplot2::scale_y_continuous(labels = add_percent, limits = c(-0.5, 0.5)) +
  ggplot2::theme_minimal()
```


### Performance for five subregions

```{r data-parameters} 
#| code-fold: true
#| code-summary: "Show/hide example code"
# FSO parameters for fictitious subregions
fso_parameters_sub <- fso_parameters |>
  # duplicating rows 5 times
  tidyr::uncount(5) |>
  # create 5 subregions
  dplyr::mutate(spatial_unit = rep(1:5, times = nrow(fso_parameters))) |>
  dplyr::mutate(spatial_unit = as.character(spatial_unit))

# Generate 5 random "cuts" to distribute the original population;
# avoid extreme values with a range of 0.1 to 0.5
cut_1 <- {
  set.seed(1)
  round(runif(1, min = 0.1, max = 0.5), digits = 2)
}
cut_2 <- {
  set.seed(2)
  round(runif(1, min = 0.1, max = 0.5), digits = 2)
}
cut_3 <- {
  set.seed(3)
  round(runif(1, min = 0.1, max = 0.5), digits = 2)
}
cut_4 <- {
  set.seed(4)
  round(runif(1, min = 0.1, max = 0.5), digits = 2)
}
# make sure everything adds up to 100%
cut_5 <- 1 - cut_1 - cut_2 - cut_3 - cut_4

# Generate population data for five subregions
df_population_sub <- fso_population |>
  # duplicating rows 5 times
  tidyr::uncount(5) |>
  # create 5 subregions
  dplyr::mutate(
    spatial_unit = as.character(rep(1:5, times = nrow(fso_population)))
  ) |>
  dplyr::mutate(
    # Distribute original population according to "cuts"
    n = dplyr::case_match(
      spatial_unit,
      "1" ~ round(n * cut_1),
      "2" ~ round(n * cut_2),
      "3" ~ round(n * cut_3),
      "4" ~ round(n * cut_4),
      "5" ~ round(n * cut_5),
      .default = NA
    ),
    .keep = "all"
  )

# Prepare subregional migration
parameters_sub_mig <- fso_parameters_sub |>
  # Create fictitious migration parameters
  dplyr::mutate(
    mig_sub = dplyr::case_when(
      # Four regions with emigration, 1 region with immigration
      spatial_unit == 1 ~ {
        set.seed(1)
        round(rnorm(1, mean = 0, sd = 0.2), digits = 4)
      },
      spatial_unit == 2 ~ {
        set.seed(2)
        round(rnorm(1, mean = 0, sd = 0.2), digits = 4)
      },
      spatial_unit == 3 ~ {
        set.seed(25)
        round(rnorm(1, mean = 0, sd = 0.2), digits = 4)
      },
      spatial_unit == 4 ~ {
        set.seed(12)
        round(rnorm(1, mean = 0, sd = 0.2), digits = 4)
      },
      TRUE ~ NA
    )
  ) |>
  dplyr::mutate(
    mig_sub = dplyr::case_when(
      spatial_unit == 5 ~ 0 - sum(mig_sub, na.rm = TRUE), TRUE ~ mig_sub
    ),
    check = sum(mig_sub, na.rm = TRUE),
    .by = c("nat", "sex", "age", "year", "scen")
  ) |>
  dplyr::select(
    nat, sex, age, year, scen, spatial_unit, birthrate, int_mothers, mor,
    emi_int, emi_nat, imm_int_n, imm_nat_n, acq, emi_nat_n, mig_nat_n, mig_sub
  )

# Calculate shares
df_population_shares <- df_population_sub |>
  dplyr::mutate(sum_n = sum(n), .by = c(nat, sex, age)) |>
  dplyr::mutate(
    share = n / sum_n,
    share = case_when(
      sum_n == 0 ~ 0,
      .default = share
    )
  )

# Apply shares
parameters_sub_size <- parameters_sub_mig |>
  dplyr::left_join(
    df_population_shares |>
      dplyr::select("spatial_unit", "nat", "sex", "age", "share"),
    by = c("spatial_unit", "nat", "sex", "age")
  ) |>
  dplyr::mutate(
    # Calculate number of incoming people per demographic group and spatial unit
    imm_int_n_distr = imm_int_n * share,
    imm_nat_n_distr = imm_nat_n * share
  ) |>
  dplyr::mutate(
    imm_int_n = imm_int_n_distr,
    imm_nat_n = imm_nat_n_distr
  )
```


```{r eval = TRUE, message = FALSE, warning = FALSE, result = FALSE, echo = TRUE}
# Run propop with tables
system.time({
  result_tables_sub <- propop::propop_tables(
    parameters = parameters_sub_size,
    year_first = 2024,
    year_last = 2055,
    population = df_population_sub,
    subregional = "net",
    binational = TRUE
  )
})

# Run propop with matrices
system.time({
  result_matrices_sub <- propop::propop(
    parameters = parameters_sub_size,
    year_first = 2024,
    year_last = 2055,
    population = df_population_sub,
    subregional = TRUE,
    binational = TRUE
  )
})
```

```{r comparison-propop-sub, echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE, result = FALSE}
# Compare results
list_propop_matrices_sub <- split(result_matrices_sub, result_matrices_sub$scen)
list_propop_tables_sub <- split(result_tables_sub, result_tables_sub$scen)

# Matrices vs tables
comparison_tables_matrices_sub <- purrr::map2(
  list_propop_matrices_sub |> purrr::map(~ .x |> rename(fso_projection_n = n_dec)),
  list_propop_tables_sub,
  compare_result
) |>
  purrr::reduce(bind_rows)
```

```{r plot-sub, echo = TRUE, eval = FALSE, message = FALSE, warning = FALSE}
# Plot comparison
comparison_tables_matrices_sub |>
  dplyr::mutate(
    spatial_unit = paste0("spatial unit ", spatial_unit),
    age = factor(age)
  ) |>
  ggplot2::ggplot(ggplot2::aes(x = factor(year), y = pe, color = age)) +
  ggplot2::geom_jitter(size = 0.8) +
  ggplot2::scale_color_manual(values = c(
    "age_00_19" = "#007AB8",
    "age_20_39" = "#ffa81f",
    "age_40_59" = "#A05388",
    "age_60_79" = "#ffe562",
    "age_80_plus" = "#96D4FF"
  )) +
  ggplot2::labs(
    title = "Differences between propop with matrices and with tables (2024-2055)",
    x = "Year",
    y = "Difference in percent"
  ) +
  ggplot2::guides(
    color = ggplot2::guide_legend(title = "age"),
    pch = ggplot2::guide_legend(title = "nationality and sex")
  ) +
  ggplot2::scale_y_continuous(labels = add_percent, limits = c(-0.5, 0.5)) +
  ggplot2::scale_x_discrete(
    breaks = c(2025, 2035, 2045, 2055)
  ) +
  ggplot2::theme_minimal() +
  ggplot2::facet_wrap(~ spatial_unit)
```

# Next steps

**Fine tuning for rates (esp. people aged 80 years and older)** \
☒ No bugs were found. Results for population components in the output still 
    differ a bit from the original (`propop()`), but only for components that
     are based on rates. \
☒ Comparison with FSO-results

**Subregions**\
☒ `propop_tables()` runs for subregions\
☒ Two methods enabled for the subregional distribution of migration (net numbers or rates)\
☐ Evaluate computation speed and accuracy (tests with real data)

**Code cleaning, function-feedback, package tests**\
☒ Code is more or less clean\
☒ Function feedback is there\
☐ Package tests and documentation (e.g. a new vignette) 

**Integration into the main branch: should `propop_tables()` remain as a separate function or become an argument to select in `propop()`?)**
